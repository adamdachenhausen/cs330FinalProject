% Jim Teresco
% Williams College, Mount Holyoke College, Siena College, The College
% of Saint Rose
%
% Last modified: Mon Dec  4 19:03:24 EST 2017
%
%
% Modified by: Pat Baumgardner, Adam Dachenhausen, Shah Syed
%
\documentclass[12pt]{article}
% extra packages to bring in
\usepackage{latexsym}
\usepackage{graphicx}      % extended graphics package
\usepackage{epsfig}        % wrapper for graphicx package
\usepackage{times}
\usepackage{url}
\usepackage{hyperref}
% set some margins, these can be defined as in, cm, pt
\setlength{\topmargin}{-0.5in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}

% a few macros that might be useful -- any time we type \eg it expands
% to the italicized version defined here
\newcommand{\etal}{{\it et al}.$\:$}
\newcommand{\eg}{{\it e}.{\it g}.$\:$}
\newcommand{\cf}{{\it cf}.$\:$}
\newcommand{\ie}{{\it i}.{\it e}.$\:$}

%% to remove page numbers, uncomment this:
%% \pagestyle{empty}

%% Define single-space command
\newcommand{\singlespace}{
  \protect\renewcommand\baselinestretch{1.0}
  \protect\normalsize
}
% use this instead if you want to disable it completely:
%%\newcommand{\singlespace}{}

%% Define double-space command (really more like 1.5 spacing)
%% This is essential for rough drafts, and not a bad idea even for
%%  final submissions
\newcommand{\doublespace}{
  \protect\renewcommand\baselinestretch{1.5}
  \protect\normalsize
}
% use this instead if you want to disable it completely:
%%\newcommand{\doublespace}{}

% This tells latex we're done defining the preamble stuff and we're
% ready to start writing the document
\begin{document}

% this removes the date that is automatically placed in the title.
% comment it out if you want the date
\date{}

% the next few items define things to go onto the title section, like,
% well, the title, and the list of authors
\title{Java Based Memory Latency Simulator}

\author{Pat Baumgardner, Adam Dachenhausen, Shah Syed\\
Department of Computer Science\\
Siena College\\
Loudonville, NY  12211
}

% this tells latex that you're done setting up title stuff and that it
% should go ahead and generate the title here
\maketitle
% leave the page number off but for this page only
\thispagestyle{empty}

% Abstract!
\begin{abstract}

The Java Based Memory Latency Simulator was developed to provide a way to
study how long it takes to move bytes of data around a common computer
system containing hard drive disks, random access memory, and a central
processing unit with cache memory. This project aims first to create a modular
system, that could be used to simulate data movement computer components, then
second to use that simulator and upgrade it to allow data to be collected about
data latency. We first focused on creating data structures that represented various
components of the computer, like a hard drive disk. Then we created a dual purpose
structure that both holds these components and interacts with the user. For this project,
we gathered data about the memory latency as an example of the modularity of the simulator.
  
\end{abstract}

% turn on double spacing
\doublespace

% Now we write the text of the paper, hopefully breaking it up into
% nice sections and subsections, using figures and tables as
% appropriate, and referring to those sections using labels instead of
% trying to number things by hand
\section{Overview}
\label{sec:overview}

The goal of this project was to create a computer memory latency simulator. 
Java was chosen as the programming language for this project for its ease of use and
it is what we, the authors are most comfortable with.
This simulator is designed to simulate data transfer from one system component 
to another. For example, from the hard drive disk, to the main memory. 

In Section~\ref{sec:memlate} we discuss abstractly how the memory latency 
simulator works, and why we built it. Section~\ref{sec:build} describes
how to build and run the simulator. In section~\ref{sec:expstats} we explain
all the types of information collected from the simulator. Then, in section~\ref{sec:data}
we present the actual data collected from the simulator, as well as actual 
real world data. Section~\ref{sec:disc} goes on to explain any discrepancies 
found between our data and the real world collected data. Finally, in~\ref{sec:conclusions}
we summarize our results, as well as report what
we have learned, and suggest how this simulator could be better
improved or used. 

\section{Simulating memory latency}
\label{sec:memlate}

\subsection{Abstract Definition}
The goal of this project was to create a Java based simulator that will allow
access to artificial data so the user could gather statistics and trends
from moving this data around the artificial system. The simulator allows simple operations
on blocks of data, not individual bytes. The simulator consists of four
primary parts: memSim, which is essentially the controller; a CPU with one level of cache;
one or more sticks or RAM; and one or more hard drive disks.

Each component's (CPU, RAM, HDD), storage is represented with a simple data structure called
a dataBlock, which represents 1024 bytes. The user then has options to handle data on any
component via the memSim terminal interface.

\subsection{Primary Audience}
Today, there are many levels of abstraction between the high-level user and their hardware.
We wanted to give a way to collect data at this low level of hardware, but not have
to be a electrical engineer working on the circuitry.

In our research, there is also very little public access on this type of data, so
it could be useful for researchers and students alike to use this simulator to collect
data for a variety of projects.

\section{Building and Running the Simulator}
\label{sec:build}

\subsection{Java}
The simulator is written in Java, and therefore, you will need to have
Java installed to run it. See \href{https://www.java.com/en/download/}
 for more.

\subsection{Acquiring Source Code}
To download the simulator code, go to \href{osfinal.dachenhausen.org}
or \href{https://github.com/adamdachenhausen/cs330FinalProject} and clone the repository.
See
\href{https:docs.github.com/en/free-pro-team@latest/github/creating-cloning-and-archiving-repositories/cloning-a-repository}
for more.

\subsection{Compiling}
\begin{itemize}

\item \textbf{Command Line}
  The source code includes two ways to compile the simulator.
  \begin{itemize}
  \item \textbf{Make}
  The simulator source code includes a Makefile, so if Make is installed, the command
  \begin{verbatim}make\end{verbatim}
  will compile the simulator.
  \item \textbf{Default}
  In the absence of Make, the default way to compile the simulator is to run  
  \begin{verbatim}javac *.java\end{verbatim}
  which will compile all of the Java files so they could be run.
  \end{itemize}
\item \textbf{Using an IDE}
  Given the multitude of IDEs that are available, please see your
  specific IDE's manual for how to compile and run the simulator.
  
\end{itemize}

\subsection{Licensing}
Before running the simulator, we would like to remind you that this
project is protected under the MIT License, so proceed at your own risk.

\subsection{Running the Simulator}
\begin{itemize}
\item \textbf{Command Line}
  Either way that the simulator was compiled, the command
{\singlespace
\begin{verbatim}
  java memSim
\end{verbatim}
}
  will start the simulator
\item \textbf{IDE}
  Given the multitude of IDEs that are available, please see your
  specific IDE's manual for how to compile and run the simulator.
\end{itemize}
Upon running the simulator, you will be prompted for a variety of 
simulator parameters. Each of these is crucial, and cannot be left blank.

The first thing the simulator will ask you is
{\singlespace
\begin{verbatim}
Is this text blue? Y/n
\end{verbatim}
}
If your terminal supports ANSI colored text, then the question should be blue,
and you should respond Y. This helps point out important data.
If your terminal does not support the colored text, then you will see something like

\begin{verbatim}
[34mIs this text blue? [0m Y/n
\end{verbatim}
in which case, if you respond n, the simulator will not use any ANSI text and
everything will print normally.

The simulator will then ask you whether you would like to LOAD or create a NEW system.

\subsection*{Load An Existing System}
The simulator will then show you three system specifications and a prompt, in which
you should choose a system by entering its system number.

\subsection*{Create A New System}
If you opt to create a new system, you will be presented with the prompt shown below,
which has sample data included. Note: very large numbers will make the simulator lag
the Java virtual machine, so please be careful when inputting this data.
{\singlespace
\begin{verbatim}
How many Hard Drives would you like?
1
And how big (in bytes) should each one be?
1024
How many RAM sticks would you like?
1
And how big (in bytes) should each one be?
512
How big (in bytes) would you like your CPU cache to be?
32
How long would you like it to take in seconds,
 to read/write to the cache?
0
How long would you like it to take in seconds,
 to read/write to the RAM?
5
Finally, how long would you like it to 
take in seconds, to read/write to a HDD?
10
\end{verbatim}
\begin{verbatim}
***********System Config**********
1 number of hard drives, each 1024 bytes big.
1 sticks of RAM, each 512 bytes big.
CPU cache is 32 bytes big.
Cache delay is: 0seconds
RAM delay is:   5seconds
HDD delay is:   10seconds
**********************************
\end{verbatim}
}
After setting up the simulator, the components will each start up, and
you will be prompted to choose an option from the menu. You can choose to either
select based on the menu number, or the name.
{\singlespace
\begin{verbatim}
Please enter the number of your selection: 1
What would you like to do next?
1.      Move Data
2.      Read Data
3.      Write Data
4.      Delete Data
5.      Help
6.      Exit
\end{verbatim}
}

In all actions, the simulator starts its timing only when user input is done,
so your data will not reflect your typing speed.

\subsection*{Reading Data}
Reading data is fairly simple, upon selecting read by entering its number into
the prompt, the simulator will show the following menu:
{\singlespace
\begin{verbatim}
Where would you like to read the data from?
1.      Hard Drive
2.      RAM
3.      CPU Cache
Please enter the number of your selection:
\end{verbatim}
}
You should then enter the number corresponding to your selection.
If you select a hard drive or a RAM stick, you will first get shown:
{\singlespace
\begin{verbatim}
Please choose a drive from 1 - 2
\end{verbatim}
}
Then, you will get shown that drive/stick's specific contents:
{\singlespace
\begin{verbatim}
****Data on this hard drive****
0: 1024 bytes big
2: 1024 bytes big
3: 1024 bytes big
*******************************
\end{verbatim}
}
You should then select the data that you wish to be read.

If you select the CPU cache, the entire contents of the cache will be read.

\subsection*{Writing Data}
Writing data is similar to reading data, as you will still be shown a prompt
of where you would like to write, and which specific drive/stick's contents to write to.
You will then be shown:
{\singlespace
\begin{verbatim}
How many bytes would you like to write?
\end{verbatim}
}
In which, you should enter the number of bytes to write. Note, if you enter a number greater
than the space remaining on the drive/stick, then the write will fail.

If you select the CPU cache, there is no limiter (other than that of Java) on maximum data
that can be written. The data structure is set up so that writing to cache is circular, so
the last n bytes are the ones stored in the cache, where n is the size of the cache.

\subsection*{Deleting Data}
Deleting data is very similar to reading data, as they are essentially the same operation.
In this case, every iteration through the stored data, the current index is set to null.

\subsection*{Moving Data}
A move is a combination of the three aforementioned commands. First, the simulator will prompt
like a read from where to read, and then delete the data from. Then the simulator will prompt
for where this data should be written. At this point the simulator will also make sure that
you do not try to read from one location, then write to that exact same location, ie. read
from drive 1, chunk 0, then try to write to drive 1, chunk 0. The simulator will re-prompt until
this is not the case. 
\section{Explanation of Data Gathered}
\label{sec:expstats}


The primary path of study through the simulator was to gather the statistics about the
events, latencies and delays that take place in the very low level of memory management.
Memory management as the name suggests is the act of managing memory in the low level of
a computer. Often represented by allocation of portions and freeing them once they are
done being used.

If we consider memory management as the super class, then the statistics that we gathered, such
as the latency of memory regulation are the one of the aspects of the memory management.
The latency is the delay or the time that it takes the data to be read from memory.
Since the movement of this data is bound to be within the speed of light,
the medium it is traveling in, this means that even though that speed is above human physical
comprehension but still there would be a delay, based on the size of the data.

We gathered the latency time, which is the time delay taking place in data transfer,reading and
writing at the lowest level of memory management. This was the primary statistic for us to consider
when building the simulator.

To represent this level of memory management the simulator was designed to hold some key components.
These components are those linked directly with the memory usage,including the
central processing unit (CPU), the Hard Drive and the RAM sticks.

The CPU further consists of cache, modern day powerful CPUS consisted of 2 level of caches, L1 and L2,
where L1 is very small compared to L2 in memory. L1 ranging from 2KB to 64KB, whereas the second level
is in the range of 256 KB to 2 MB. Cache is used for quicker access by the CPU of the data that it
frequently uses. Cache stores that data and thus decreasing the latency. However, in the simulator we
implemented a single level of cache with a variable size, which is input by the user.

Further down the hierarchy of memory management, we have the RAM, which is relatively slower to CPU but bigger
in size by quite some margin. The RAM, which translates to Random Access Memory is a volatile form of memory
built by several memory cells. There are two types of RAMs; DRAM and SRAM, even thought we did not distinguish
between them in our simulator. Given that the RAM is slower compared to the CPU(cache) it takes time to read
and move data off it. In the simulator we kept the size and the number of RAM sticks a variable, so
the user inputs the value for each. Since the RAM is volatile it loses all the data it has on it, once we
take the power off it. As soon as the power is turned on, the alot of important section of OS is read from
the hard drive and put onto the RAM so some important functions can be accessed quickly instead of reading
it off the hard drive which is way slower. This OS data along with other make up alot the RAM usage when the
computer is running. Running other process lead to more writing and reading off the RAM which leads to different
delays.

Finally comes the Hard Drive, which is the biggest form of permanent memory but the slowest one. It is
extremely large compared to both RAM and cache. Almost all the software including the OS is stored on
the HDD. HDDs have evolved in many ways over the course of times, making them quicker, but they have
remained slower compared to RAM and CPU always. In our simulator we have built an HDD on arrays of bytes,
just like the RAM and cache. 

The movement, reading and writing of the data to any of the components was timed, which helped
us to  collect the major statistics we needed  here. The latency which was  going to be the
major finding of the simulation was calculated through a stopwatch implemented
inside our program. As we kept clocking, the time was a projected ratio of the time that was supposed to
take place on the basic level. Thus, the time gathered was reduced to the ratio fully suited for the
level of details being dealt with in the simulator.

The Memory, which was the core component of the simulator and the primary part of each component
was represented by arrays of byte type. As the simulation went on, these arrays in each of the components
were modified depending upon the event taking place. This modification gave us the data for how the size
of data acts proportional to the latency and the delay in the transfer, writing and reading of data. The size
of data was one of the major field of the statistics being gathered. We studied upon the size of the
data as how much of variance does it brings to the clock.

As the variables we had in the simulation were the number of Cores in the CPU,
the number of hard drives, the size of hard drive in bytes, the number of RAM sticks, the size of
each of the RAM stick and the size of the CPU Cache, we kept a record of each combination. However,
even with the CPU having a variable number of cores, for the path of study being conducted, we maintained
it to be 1 throughout the study. The simulator was structured to take in a value for each of the variables,
except the number of cores. This led to new fields of data for statistics being gathered.
The size of cache in the CPU, which is a small form of memory and the quickest one out of RAM and HDD, was
varied to yield a different result, which went into the into the table of statistics too.
The same was done with the RAM, which relatively larger form of memory. We gathered how the data access
and transfer on RAM vary in the aspect of Time as with different sizes, and how slower or faster was the case
with the accessing, editing and transferring from and to the Hard drives.

The number of RAM sticks and the number of hard drive was also an important variable in deciding the latency,
the access time and the writing time, given that increasing the number of these components meant more
size but a different access time.

\section{Data Gathered}
\label{sec:data}

Latency Time in the all 3 major components being implemented in the simulator vary accordingly to their sizes,
that becomes the reason why cache is the fastest between RAM and the HDD.

Starting with the hardrive latency time for the input and output of data as it is the largest size of all memories here.
The latency of a hard drive is a combination of it RPM, Seek Time and Transfer time. In the simulator that we
implemented, we didnt go into details to a point that we offer the RPM, Seek time and the Transfer time as
a variable to the user. However we implemented the HDD on data blocks instead of platters, which acted as
partitions. 

Rotatational latency of a hard drive is how long does it take a platter to spin, as after all it is a mechanical
component bounded by a certain speed.
According to \cite(1) Eric Shanks from ithollow.com, the following were the Hard Drive Rotational latencies in 2013.

\begin{tabular}{|c|c|}
  \hline
  RPMs & Rotational Latency(ms)\\
  \hline
  5400 & 11 ms\\
  \hline
  7200 & 8 ms\\
  \hline
  10000 & 6 ms\\
  \hline
  15000 & 4 ms\\
  \hline
\end {tabular}

Seek time; which is the time it takes for the Read-Write to move up and down the platter.
The Seek time itself is comprised of a series of phase times. The first being the acceleration phase,
the read write arm starts to move, then comes the coasting phase when the arm is moving at full speed. This
is followed by the deceleration phase where the read write arm slows down. Then finally comes the
settling phase as the read write head stops right at the data it needs.
The average seek time of hardrives of size 300 GB to 1TB ranged from an average time of 4ms to 9ms.
(source: \cite{three} )

The last part of total I/O latency for hard drive is the transfer time, which is the time it takes the
data to be transfer from or to the Read-Write head. Compared to Rotational Latency and seek time, transfer
time is insignificant, given that the mechanical movements take more time than data movement which is more of
movement of energy packets.

After all this we come to an equation:

I/O Latency Time of HDD = Rotational Latency + Seek Time + Latency Time 

In an extensive calculation done by Remzi Arpaci-Dusseau and Andrea Arpaci-Dusseau, in the \cite{three},
two hard drives one Cheetah, and the other being Barracuda was compared for the I/O latency time. The size of
data being dealt with was 100 MB. However, another controller in the comparison was whether the data reading or writing
was sequential or random. Sequential meant that large chunks of data are just being read and written which are in
sequence, whereas the Random transfer just meant Random data was selected from a read issue some where on the disk,
which is how the data for applications work. Mind it that the data we represented in the simulator was also sequential
and not random, as the hardrive implemented was built of data blocks.

The I/O Latency time along with other statistics mentioned above was (taken from the source \cite{three}): 


\begin{tabular}{|l|rr|}
  \hline
  HDD & Cheetah 15K.5 & Barracuda\\
  \hline
  Capacity & 300 GB & 1 TB\\
  \hline
  RPM & 15,000 & 7,200\\
  \hline
  Average Seek & 4 ms & 9ms\\
  \hline
  Platters & 4 & 4\\
  \hline
  T I/O Random & 6 ms & 13.2 ms\\
  \hline
  T I/O Sequential & 800 ms & 900 ms\\
  \hline
\end {tabular}

\subsection*{In our simulation}

Now coming to our second component RAM and how the data tranfer works in their and what delays take place.
RAM is a way smaller storage device compared to HDD and is alsos volatile, but that makes it quicker than
the HDD. The Latency of data movement in RAM is comprised primarily of CAS latency which translates to
Column Address strobe latency. Since the RAM is built upon columns or cells of memory,
CAS latency means how much time it would take the RAM to access the memory cells, read the data and make it
available as an output. And again, in the simulation we were not able to completely configure the design of
the RAM to this extent however we did implement a RAM on data blocks.

Over the course of Time the latency of RAM has improved, but compared to the bandwidth and capacity it has
been on the very low side. According to a research done by Kevin Chang from CMU, in his paper 'Understanding
and Improving the Latency of D-RAM based Memory Systems'(\cite {DRAMTimings}) in the period of 1999 - 2017,
the capacity of RAM has increased a gigantic 128 times, where as the Bandwidth of a RAM has increased a
good enough 20 times, however the improvenement in latency had  only a factor of 1.3x. We can safely assume
that the latency of a RAM has been consistent compared to the latency of Hard Drive over time or the CPU.

Compared to the RAM the gap between the CPU latency and the RAM latency has been growing at a high rate. As
discussed previously the latency of a RAM hasn't had much improvement in the last 3 decades. Sangyeun Cho
from UPittsburg, comes with the data that considering 2005, the improvement in RAM latency has been less than
10 times than it was in 1980. However on the other hand the CPU latency has steered up to a performance of
a whopping 10000 times better in 2005 than it was in 1980.

When we talk about the CPU, we are dealing with the smallest form of major memory in the CPU yet the fastest one.
As mentioned in the previous section, the CPU consists of caches to save the time to fetch frequent data
again from the memory. Given that the modern CPUs have 2 levels of cache built in them, we were only able to
implement a single level on our simulator. The CPU latency is comprised of many factors or sometimes not. That
depend upon how effecient is cache working. If the CPU cache does not have the data required than the CPU has
to use the buses to fetch the data from the memory, compromising the bus bandwidth and timing in the process.
These two different situations can yield a very different latency period.

As of 2012 these were some of the Latencies, that includes different operation on a low level
and at the high level.(Source: \cite {Latencies})

\begin{tabular}{|l|c|}
  \hline
  L1 cache reference & 0.5 ns\\
  \hline
  Branch mispredict & 5 ns\\
  \hline
  L2 cache reference & 7 ns\\
  \hline
  Mutex lock/unclock & 25 ns\\
  \hline
  Main memory reference & 100 ns\\
  \hline
  Compress 1k bytes with zippy & 3000 ns / 3 us\\
  \hline
  Send 1 KB over Gbps network & 10000 ns / 10 us\\
  \hline
  Read 4 KB randomly from memory & 150000 ns / 150 us\\
  \hline
  Read 1 MB sequentially from memory & 250000 ns / 250 us\\
  \hline
  Round trip within same data center & 500000 ns / 500 us\\
  \hline
  Read 1 MB sequentially from SSD & 1000 us / 1 ms\\
  \hline
  Disk Seek & 10000 us / 10 ms\\
  \hline
  Read 1 MB sequentially from the disk & 20000 us / 20 ms\\ 
  \hline    
\end {tabular}

Not all of this information, especially concerning network is that closely relevant to our field of study, but
we can certianly see the latencies that included reading, writing and referencing from the CPU caches, memory
and the drives had a huge difference in between them. The low level operations that took place within the
CPU were the quickest of all, referencing Caches and branching. Secondly referencing the RAM (7 ns) was slower than
referencing the the caches (0.5 ns and 7 ns) but alot faster that going to a and reading from disk which was almost a
20 million times slower than refernecing the L1 Cache and upto a hundred thousand times slower than referencing
the RAM. 

\section{Discrepancies}
\label{sec:disc}

The goal of the project was to find out about the varying latencies of some of the major components of the CPU, with
or without the simulator. By implementing a simulator good enough to differentiate and manage data we were able to
find out more about the memory management in an environment ran by threads. However, since there exists some complex
and deep details and components in the real world units that we represented, we were only able to implement as much
as the basic level of each component.
The real world data that we represented made up most of our information in the paper, but that was along with the
fact that the data we imported, was a combination of several different projects and researchs.
Starting from the hard drive we did not represent the sectors, platters and other mechanical components, instead
we implemented the HDD using data blocks, thus we were only able to gather stats for a sequential read and write.
A similar implementation of RAM meant that we did not explicitly render the memory cells in the RAM but only the
data blocks which act as those cells.
For the CPU we only represented a single level of cache a L1, while almost all the modern CPUS work on dual level
of cache.
Being programmed in java our simulator was bounded by the high level barrier, so to represent the low
level of memory management, we did have to implement delays ourselves. Our delays were then rationalized according
to the time it takes in the low level. 
A lot that was not gathered through the simulator, a deep analysis of sources did cover for that. Especially getting
to know the latencies of new combinations of components that we did not implement in out simulator helped us to a
more realistic approach. The research itself was based upon a latency simulator with a concentration on what makes
up the delays in a real world programming system. 


\section{Conclusions} 

\label{sec:conclusions}

Memory Management within a memory system is a complex set of organizations of several different peices, which
themselves are a set of several different elements. So if we are to study the time delays as a superset of
memory latencies, we cannot just discuss the general latencies of each component seperately. But one must
realize that the components are very closely linked with each other. An example of this would be that if a
a CPU references either  cache and it hits, that would be an ideal situation for the a real model, but if does
not find what it needs then it has to ref the memory or eventually the Disks, resulting in so many differnt
factors for delays, including but not only, the CAS latency of the RAM, the HDD I/O latency, which further
includes the delays of rotation, read write head, settling time etc.


\singlespace
\bibliographystyle{abbrv}
\bibliography{references}

% tell latex we're done.  Anything beyond this line will be ignored.
\end{document}
